\chapter{ چند نمونه ساده توصیف Z}\label{chapter4}


\section{نمونه اول: کتابچه تولد}\index{sample1}
بهترین راه برای درک زبان $Z$ مطالعه نمونه های ساده است. به عنوان اولین نمونه، سیستمی پیاده سازی می شود که در آن کتابچه تولد، به جای استفاده از دفترچه و خودکار، توسط یک سیستم کامپیوتری ایجاد می شود. در این سیستم، تاریخ تولد افراد ثبت می شود و سیستم قادر است که با نزدیک شدن روز تولد افراد، آن را یادآوری کند.\\
شخصی که می خواهد برای خود در سیستم کتابچه تولد، یک حساب کاربری ایجاد کند، باید نام افراد و تاریخ تولد آنها را ثبت کند.  بنابراین مجموعه ای از نام ها و مجموعه ای از تاریخ ها را، به عنوان نوع اصلی، در این توصیف خواهیم داشت.\\
 \[
 [NAME, DATE]
 \]
 \\
 تعریف این دو مجموعه باعث می شود که بتوان مجموعه ها را بدون بیان صریح نوع اشیایی که شامل می شوند، نامگذاری کرد.  \\
 اولین جنبه سیستم، تشریح فضای حالت آن است که با استفاده از شمای شکل 
 \ref{fig4-1}
 توصیف شده است.\\
\begin{figure}
\centering
\begin{schema}{\mathit{BirthdayBook}}
\mathit{known} :\mathbb{P}\enspace NAME\\
\mathit{birthday} : NAME \nrightarrow DATE
\ST
\mathit{known} = \dom \enspace \mathit{birthday}\\
\end{schema}
\caption{}
\label{fig4-1}
\end{figure}
مشابه دیگر شِماها، این شِما نیز شامل دو بخش است که با یک خط تقسیم مرکزی از یکدیگر جدا شده اند. در بخش بالا، متغیرها اعلان شده اند و در بخش پایین، رابطه بین متغیرها و مقادیرشان مشخص شده است. در این مورد، فضای حالت سیستم و دو متغیری که نشاندهنده مشاهدات بااهمیت هستند و می توانند حالت ها را ایجاد کنند، تشریح شده اند:
\\
$\bullet known:$
مجموعه ای از نام هاست که تاریخ تولد آنها ثبت شده است.
\\
$\bullet birthday:$
تابعی است که زمانیکه نام معینی مشخص می شود، تاریخ تولد منتسب به آن را می دهد.

 
بخشی از شِما که در زیر خط قرار دارد، رابطه ای را نشان می دهد که در تمامی حالت های سیستم، درست است و با پس از اعمال عملگرها نیز همچنان این رابطه درست باقی می ماند. در این مثال، رابطه بیانگر این است که مجموعه $known$ مشابه دامنه تابع $birthday$ است. این متغیر شامل مجموعه ای از نامهاست که برای آنها تاریخ تولدی ثبت شده است. این رابطه، در سیستم غیرقابل تغییر است.
\\

در این مثال، غیرقابل تغییر بودن، به مقدار متغیر $known$ اجازه می دهد که از مقدار  $birthday$ مشتق شود. در واقع $known$ یک مولفه مشتق شده از حالت است و می توان سیستم را بدون اشاره به $known$ مشخص کرد. البته باید توجه داشت که دادن نام ها، خوانایی توصیف را افزایش می دهد زیرا یک دید انتزاعی از فضای حالت کتابچه تولد را ایجاد می کند.
\\
یکی از حالت های ممکن سیستم حالتی است که شامل سه نفر در مجموعه $known$ است که تاریخ های تولد آنها با استفاده از تابع $birthday$ ثبت شده است:

\[
\mathit{known} = \{John, Mike, Susan\}
\]
\[
\mathit{birthday} = \{John\mapsto 25-Mar,\\
\hspace{60pt} Mike \mapsto 20-Dec,\\
\hspace{60pt} Susan \mapsto 20-Dec\}.\\
\]

ویژگی غیرقابل تغییر بودن در مثال فوق ارضا می شود زیرا تابع $birthday$ دقیقا برای هر سه اسم نام موجود در $known$، یک روز را ثبت کرده است.
\\
توجه کنید که در شرح فضای حالت سیستم، محدودیتی برای تعداد زمان تاریخ تولدهای ثبت شده در کتابچه تولد، قرار داده نشده است. همچنین فرمت خاصی برای ورود نام ها و روزهای تولد تعریف نشده است. از طرف دیگر برای هر فرد تنها یک تاریخ تولد ثبت می شود زیرا که $birthday$ یک تابع است، اما برای دو نفر متفاوت ممکن است یک تاریخ تولد ثبت شود (همانشور که در مثال فوق نیز این اتفاق رخ داده است).
\\
در ادامه عملگرهای سیستم تعریف خواهند شد. اولین عملگر، عملگری است که امکان اضافه کردن یک تاریخ تولد جدید را فراهم می کند. این عملگر در شِمای شکل\ref{AddBirthday} 
توصیف شده است.

\begin{figure}
\centering
\begin{schema}{\mathit{AddBirthday}}
\vartriangle \mathit{BirthdayBook}\\
\mathit{name?}:NAME \\
\mathit{date?}: DATE \\
\ST
\mathit{name?} \notin \mathit{known}\\
\mathit{birthday'}=\mathit{birthday}\cup \{\mathit{name?}\mapsto \mathit{date?}\}
\end{schema}
\caption{}
\label{AddBirthday}
\end{figure}

اعلان 
$\vartriangle \mathit{Birthday}$
بیانگر این مطلب است که این شِما، یک تغییر حالت را توصیف می کند. در این شِما چهار متغیر معرفی می شوند: 
$\mathit{known}$،
$\mathit{birthday}$،
$\mathit{known'}$ و
$\mathit{birthday'}$.
دوتای اول مربوط به مشاهدات حالت، قبل از تغییر و دوتای بعدی، مربوط به مشاهدات حالت، بعد از تغییر هستند.
هر زوج متغیر، محدودیت غیرقابل تغییر بودن را ارضا می کنند.
سپس دو ورودی عملگر، اعلان می شوند. برای اعلان ورودی ها، پس از اعلان نام ورودی، علامت سوال گذاشته می شود.
\\
بخشی از شِما که در زیر خط قرار گرفته است، ابتدا به بیان یک پیش شرط برای انجام موفقیت آمیز عملگر می پردازد، به این ترتیب که نامی که می خواهد اضافه شود نباید قبلا در سیستم ثبت شده باشد. این پیش شرط منطقی به نظر می رسد زیرا به ازای هر نفر تنها یک تاریخ تولد باید در سیستم ثبت شود. اینکه اگر پیش شرط برآورده نشود، چه اتفاقی خواهد افتاد، در این توصیف مشخص نشده است.
\\ اگر پیش شرط برآورده شود در خط بعدی تابع 
$\mathit{birthday}$
توسعه داده می شود و یک نام جدید به تاریخ تولدش نگاشت می شود.
انتظار می رود که نام جدید نیز به مجموعه نام های موجود در سیستم اضافه شود.
\[
\mathit{known'}=\mathit{known} \cup \{ \mathit{name?}\}.
\]

درواقع این مطلب از توصیف 
$\mathit{AddBirthday}$
، با استفاده از ویژگی غیرقابل تغییر بودن حالت، پیش و پس از اعمال عملگر، قابل اثبات است.
\[
\mathit{known'}= \dom \enspace \mathit{birthday'} \\
\hspace*{37pt} =\dom \enspace (\mathit{birthday} \cup \{ \mathit{name?}\mapsto \mathit{date?}\}) \\
\hspace*{37pt} =\dom \enspace \mathit{birthday} \cup \dom \{ \mathit{name?}\mapsto \mathit{date?}\}\\
\hspace*{37pt} =\dom \enspace \mathit{birthday} \cup  \{ \mathit{name?}\}\\
\hspace*{37pt} = \mathit{known} \cup  \{ \mathit{name?}\}\\
\]
ویژگی های اثبات و حالت، مانند آنچه که در بالا ذکر شد، تضمین میکنند که توصیف ها از دقت بالایی برخوردارنند که در نهایت منجر به توسعه سیستم هایی می گردد که درنهایت رفتاری بدون اشکال خواهند داشت.
\\
 دو واقعیت درخصوص 
 $dom$
 در این استدلال وجود دارد که مثالی از یک قانون ریاضی است. این قانون عبارت است از:
 \[
 dom(\mathit{f\cup g})= (dom \enspace \mathit{f}) \cup (dom \enspace \mathit{g})\\
 dom\{\mathit{a \mapsto b}\}= \{ \mathit{a}\}.
 \]
 عملگر دیگری که برای یافتن روز تولد افراد بکار می رود، با استفاده از شِما شکل \ref{FindBirthday}  تعریف شده است.
\begin{figure}
\centering
\begin{schema}{\mathit{FindBirthday}}
\Xi \mathit{BirthdayBook}\\
\mathit{name?}:NAME \\
\mathit{date!}: DATE \\
\ST
\mathit{name?} \in \mathit{known}\\
\mathit{date!}=\mathit{birthday}(\mathit{name?})
\end{schema}
\caption{}
\label{FindBirthday}
\end{figure}
در شِمای شکل \ref{FindBirthday} دو علامت جدید دیده می شود. اعلان 
$\Xi \mathit{BirthdayBook}$
بیانگر این است که این عملگر منجر به تغییر حالت نخواهد شد. به این معنا که مقدار $\mathit{known'}$
و
$\mathit{birthday'}$
، در مشاهدات بعد از اعمال عملگر، برابر است با مقدار 
$\mathit{kKnown}$
 و
$\mathit{birthday}$
 قبل از اعمال عملگر. استفاده از 
 $\Xi \mathit{BirthdayBook}$
 در خط اول شِما تاثیری مشابه این دارد که در خط اول 
 $\vartriangle \mathit{BirthdayBook}$
 آورده شود و دو تساوی زیر نیز در ادامه و در زیر آن نوشته شوند:
 \[
 \mathit{known'} = \mathit{known}\\
 \mathit{birthday'}= \mathit{birthday}
 \]
 علامت جدید دیگری که در این شِما استفاده شده است، نمادی است که بعد از $\mathit{date}$ آمده است و تعیین می کند که این متغیر یک خروجی است. عملگر 
 $\mathit{FindBirthday}$
  نام را به عنوان ورودی دریافت م کند و تاریخ تولد متناسب با آن را به عنوان خروجی، می دهد. پیش شرطی که برای انجام موفقیت آمیز این عملگر مورد نیاز است این است که 
  $\mathit{name?}$
   یکی از نام های موجود در سیستم باشد. در اینصورت خروجی 
   $\mathit{date!}$
    برابر است با مقدار تابع $\mathit{birthday}$ که برای آرگومان 
    $\mathit{name?}$
    در نظر گرفته شده است.
    \\
    یکی از پرکاربردترین عملگرهای موجود در این سیستم، عملگری است که جهت یادآوری روز تولد استفاده می شود. این عملگر هر روز، اسامی افرادی را که در آن روز متولد شده اند، اعلام می کند. این عملگر یک ورودی تحت عنوان 
    $\mathit{today?}$
     و یک خروجی تحت عنوان 
     $\mathit{cards!}$
     دارد که مجموعه ای از نام هاست که می تواند صفر، یک، دو و یا تعداد بیشتری از افرادی باشد که روز تولدشان برابر با روز تعیین شده است و باید در این روز برای آنها کارت تولد فرستاد.
\begin{figure}
\centering
\begin{schema}{\mathit{Remind}}
\vartriangle \mathit{BirthdayBook}\\
\mathit{today?}:DATE \\
\mathit{cards!}: \mathbb{P}\enspace NAME \\
\ST
\mathit{cards!}= \{ \mathit{n: \enspace known | \enspace birthday(n)= \enspace today?}\}
\end{schema}
\caption{}
\label{Remind}
\end{figure}      
 در شِمای شکل \ref{Remind} که به توصیف عملگر 
 $\mathit{Remind}$
  می پردازد نیز از علامت $\vartriangle$ استفاده شده است که بیانگر این است که حالت تغییر نمی کند. این شِما پیش شرط ندارد. خروجی 
  $\mathit{cards!}$
  برابر است با مجموعه ای از تمام مقادیر $n$ از مجموعه $\mathit{known}$ که مقدار تابع $\mathit{birthday}$ آنها برابر با $\mathit{today?}$ است. به بیان کلی تر، $y$ عضوی از مجموعه 
  $\{x:S|...x...\}$
   است اگر $y$ عضوی از $S$ باشد و شرط
   $...y...$،
   با جایگذاری $y$ به جای $x$ بدست آید. در واقع می توان گفت:
   \[
   y \in \{x:S|...x...\}\Leftrightarrow y \in S \land (...y...).
   \]
که در مثال ما:
\[
\mathit{m \in \{n: known | birthday(n)=today?}\}\\
\hspace{25pt}  \Leftrightarrow \mathit{m \in known \land birthday(m)=today?}.
\]
یک نام $m$ در مجموعه خروجی $\mathit{cards!}$ قرار دارد اگر و فقط اگر در سیستم وجود داشته باشد و روز تولدی که برای آن ثبت شده است برابر با $\mathit{today?}$ باشد.
\\
برای به پایان رساندن این توصیف، باید حالت شروع سیستم را بیان کرد. این حالت، حالت اولیه 
\LTRfootnote{initial state}
سیستم می گویند و بوسیله شِمای شکل
\ref{InitBirthdayBook}
 توصیف می شود. در این شِما، کتابچه تولد به نحوی توصیف میشود که در آن مجموعه 
 $\mathit{known}$
 خالی درنظر گرفته شده است. همچنین تابع $\mathit{birthday}$ نیز تهی درنظر گرفته می شود.
 
\begin{figure}
\centering
\begin{schema}{\mathit{InitBirthdayBook}}
 \mathit{BirthdayBook}\\
\ST
\mathit{known}= \varnothing
\end{schema}
\caption{}
\label{InitBirthdayBook}
\end{figure} 
یک پیاده سازی صحیح توصیفی که روزهای تولد را ذخیره می کند و نمایش می دهد، باید بنحوی باشد که هیچگونه ورودی اشتباهی به آن وارد نشود. اما این توصیف یک ایراد جدی دارد: زمانیکه کاربر سعی می کند تاریخ تولد شخصی را به سیستم وارد کند که در حال حاضر در سیستم وجود دارد، یا سعی در تاریخ تولد شخصی داشته باشد که در سیستم وجود ندارد. برای این وضعیت ها، هیچ حالتی در سیستم توصیف نشده است. در این وضعیت ها سیستم باید یک رفتار مسئولیت پذیر از خود بروز دهد به این نحو که ورودی های غلط را نادیده بگیرد. \\
 در توصیف سیستم کتابچه تاریخ تولد، رفتار سیستم در قبال ورودی های صحیح، بطور واضح و شفافی بیان شده است. این توصیف نیازند تغییراتی که بتواند ورودی های غلط را نیز مدیریت کند. در واقع سیستم باید موقعیت های خطا را شناسایی کند و در صورت بروز هریک از آنها، رفتاری متناسب از خود بروز دهد. با اصلاح توصیف ها، به توصیف های قوی تری خواهیم رسید که  عملیات حساب شِمای Z را بکار می برند.
 \\
 خروجی با عنوان 
 $\mathit{result!}$
 را به تمامی عملیات های عریف شده برای سیستم، اضافه می کنیم. اگر عملیات با موفقیت به پایان رسید، این خروجی ارزش 
 $ok$
 خواهد گرفت، اما اگر خطایی شناسایی شد، دو مقدار
 $\mathit{already\_known}$
 و
 $\mathit{not\_known}$
 به آن تخصیص داده می شود.
 تعریف نوع آزاد
\LTRfootnote{free type}
برای $REPORT$ که دقیقا شامل سه مقدار می باشد، در ادامه آمده است.
\\
\[
REPORT ::= \mathit{ok} | \mathit{already\_known} | \mathit{not\_known}.
\]

  در شکل 
  \ref{Success}
  شِمای $\mathit{Success}$ تعریف شده است که به توصیف وضعیتی می پردازد که در آن نتیجه $\mathit{ok}$ است.
 \begin{figure}
\centering
\begin{schema}{\mathit{Success}}
 \mathit{result!}:\enspace \mathit{REPORT}\\
\ST
\mathit{result!}=  \mathit{ok}
\end{schema}
\caption{}
\label{Success}
\end{figure}       
عملگر ترکیب عطفی در حساب شِما، این اجازه را می دهد که دو شمای 
$\mathit{AddBirthday}$
و
$\mathit{Success}$
به صورت زیر با یکدیگر ترکیب شوند.
\[
\mathit{AddBirthday \wedge Success}
\]
ترکیب این دو شِما، به شرح عملیاتی می پردازد که در آن برای ورودی صحیح، دو عملی که بوسیله 
$\mathit{AddBirthday}$
و
$\mathit{Success}$
توصیف شده اند، رخ دهد و نتیجه
$\mathit{ok}$
شود.
برای هر خطایی که ممکن است در ورودی رخ دهد، باید شِمایی تعریف کرد که گزارشی مناسب را در صورت رخداد خطا ارائه دهد. شِمای مربوط به گزارش 
$already\_known$
  در شکل \ref{AlreadyKnown} نشان داده شده است. این خطا زمانی رخ می دهد که ورودی 
$\mathit{name?}$
عضوی از مجموعه 
$\mathit{known}$
باشد.

\begin{figure}
\centering
\begin{schema}{\mathit{AlreadyKnown}}
 \Xi\mathit{BirthdayBook}\\
 \mathit{name? : NAME}\\
 \mathit{result!:REPORT}
\ST
\mathit{name? \in Known}\\
 \mathit{result!= already\_known}
\end{schema}
\caption{}
\label{AlreadyKnown}
\end{figure} 
اعلان 
$\Xi\mathit{BirthdayBook}$
بیان می کند که در صورت بروز خطا، حالت سیستم تغییر نمی کند. 
\\
می توان این توصیف را با توصیف هایی که پیش تر بیان شدند، ترکیب کرده و نسخه کامل تری از 
$\mathit{AddBirthday}$
را بدست آورد.
\[
\mathit{RAddBirthday \cong (AddBirthday \wedge Success) \vee AlreadyKnown. }
\]
این تعریف شِمای جدیدی را معرفی می کند که 
$\mathit{RAddBirthday}$
نام دارد. این شِما با ترکیب سه شِما در سمت راست رابطه، بدست آمده است. اگر ورودی 
$\mathit{name?}$
در حال حاضر وجود داشته باشد، حالت سیستم تغییر نمی کند و نتیجه
$\mathit{already\_known}$
برگردانده می شود. در غیر اینصورت، تاریخ تولد جدید، با استفاده از 
$\mathit{AddBirthday}$
 به پایگاه داده اضافه می شود و و نتیجه 
$\mathit{ok}$
برگردانده می شود.
\\
برای انجام عملیات 
$\mathit{RAddBirthday}$
باید نیازهای متنوعی را توصیف کرد و سپس این نیازها را در یک توصیف با یکدیگر ترکیب کرد. این ترکیب در نهایت رفتار عملیات را نشان می دهد. این بدان معنا نیست که نیازها بصورت جداگانه پیاده سازی شوند و پیاده سازی های مختلف با یکدیگر ترکیب گردند. در واقع این پیاده سازی سعی می کند که مکان مناسبی را برای تاریخ تولد جدید پیدا کند و همزمان هم بررسی می کند که نام ورودی پیش تر در پایگاه داده ثبت نشده باشد. کد مربوط به عملیات اضافه کردن ورودی جدید و بررسی خطا، باید با یکدیگر ترکیب شوند. 
\\
 عملیات
 $\mathit{RAddBirthday}$
 بطور مستقیم و با نوشتن یک شِما، توصیف می شود. این شِما از ترکیب گزاره های سه شِمای 
 $\mathit{AddBirthday}$
 ،
 $\mathit{Success}$
 و
 $\mathit{AlreadyKnown}$
 بدست می آید. تاثیر عملگر 
 $\vee$
 در ساخت شِما این است که گزاره های شِمای جدید از ترکیب فصلی گزاره های دو شِمای دیگر بدست می آید. بطور مشابه، تاثیر عملگر
 $ \wedge$
 نیز منجر به ترکیب عطفی دو گزاره خواهد شد. متغیرهای دو شِما نیز با یکدیگر ادغام می شوند.
  در این مثال، ورودی
  $\mathit{name?}$
  و خروجی
  $\mathit{result!}$
  و چهار مشاهده مختلف از حالت های قبل و بعد از اعمال عملگر، با استفاده از دو آرگومان
   $\vee$
    ، به اشتراک گذاشته می شوند.   
\begin{figure}
\centering
\begin{schema}{\mathit{RAddBirthday}}
 \Delta \mathit{BirthdayBook}\\
 \mathit{name? : NAME}\\
 \mathit{date?:DATE}\\
 \mathit{result!:REPORT}
\ST
\mathit{(name? \notin Known \wedge}\\
 \mathit{birthday'=birthday\cup\{ name?\mapsto date?\}}\wedge \\
 \mathit{result!=ok)}\\
 (\mathit{name? \in known \wedge}\\
 \mathit{birthday'=birthday\wedge}\\
 \mathit{result!=already\_known)}
\end{schema}
\caption{}
\label{RAddBirthday}
\end{figure}
با توجه به اینکه برای توصیف 
$\mathit{RAddBirthday}$
از یک تک شِما استفاده شد، لازم است که بطور صریح بیان شود که حالت سیستم در وضعیت بروز خطا، تغییر نخواهد کرد. این مساله پیش تر با اعلان
$\Xi \mathit{BirthdayBook}$
، بطور ضمنی، بیان می شد.
\\
نسخه تکامل یافته عملیات 
$\mathit{FindBirthday}$
باید بتواند درصورتیکه نام مورد جستجو در پایگاه داده وجود نداشته باشد، این مورد را گزارش دهد. این گزارش خطا در شِمای شکل 
\ref{NotKnown}
نشان داده شده است. 

\begin{figure}
\centering
\begin{schema}{\mathit{NotKnown}}
 \Xi\mathit{BirthdayBook}\\
 \mathit{name? : NAME}\\
 \mathit{result!:REPORT}
\ST
\mathit{name? \notin Known}\\
 \mathit{result!= not\_known}
\end{schema}
\caption{}
\label{NotKnown}
\end{figure} 
عملیات تکامل یافته
$\mathit{FindBirthday}$
نیز که بصورت شِمای 
$\mathit{RFindBirthday}$
تعریف می شود، با استفاده از 
$\mathit{FindBirthday}$
و گزارش های 
$\mathit{Success}$
و 
$\mathit{NotKnown}$
قابل توصیف است.
\[
\mathit{RFindBirthday \cong (FindBirthday \wedge Success) \vee NotKnown.}
\]
عملیات 
$\mathit{Remind}$
در هر زمانی می تواند فراخوانده شود. این عملیات هیچگاه منجر به خطا نمی شود اما نسخه تکامل یافته آن نیازمند اضافه کردن گزارش موفقیت است.
\[
\mathit{RRmind \cong Remind \wedge Success.}
\] 
\section{نمونه دوم: تجزیه متن به واژگان}\index{sample2}
یک متن شامل دنباله ای از کاراکترهاست. یکی از کاراکترهای خاص که در متن بسیار استفاده می شود، کاراکتر فضای خالی 
\LTRfootnote{Blank} 
است. کاراکترهای فاصله
\LTRfootnote{space}
، شکست خط
 \LTRfootnote{line break}
و tab نیز نوع خاصی از فضای خالی هستند. درحقیقت، واژه، دنباله ای از کاراکترها، غیر از فضای خالی، است. بنابرای فضای خالی کاراکتری است که دو واژه را از هم جدا می کند. فاصله، دنباله ای از کاراکترهای فضای خالی است. 
\begin{figure}
\centering
\begin{schema}{[CHAR]}
blank :\mathbb{P}CHAR
\ST
TEXT == seq \enspace CHAR\\
SPACE == seq_1 \enspace blank\\
WORD == seq_1 \enspace (CHAR \setminus blank)
\end{schema}
\caption{}
\label{CHAR}
\end{figure}
TEXT ممکن است شامل دنباله ای تهی از کاراکترها باشد.SPACE و WORD باید شامل حداقل یک کاراکتر باشند. به همین دلیل آنها را بصورت $seq_1$ اعلان کردیم. 
\\
تابع شمارش کلمات که با نام $words$ نامگذاری شده است. تابع $words$ دنباله ای از تمام واژه های موجود در متن را بازمی گرداند. به عنوان مثال :
\\
$
words <H,o,w, ,a,r,e, ,y,o,u,?>=<<H,o,w>,<a,r,e>,<y,o,u>>
$
\\
واضح است که تابع$words$ تابعی از 
$TEXT$
 به دنباله ای از 
 $WORD$
  است. برای تعریف تابع $words$ تمام الگوهای ممکن واژگان و فاصله ها در نظر گرفته می شود و برای هرکدام، یک تساوی نوشته می شود.
\begin{figure}
\centering
\begin{axdef}
words: TEXT \rightarrow seq \enspace WORD
\ST
\forall s:SPACE; \enspace w:WORD; \enspace l,r:TEXT;\\
words<>=<>\wedge\\
words \enspace s=<> \wedge \\
words \enspace w=<w>\wedge \\
words(s\frown r)=words \enspace r\wedge \\
words(l \frown s)=words \enspace l\wedge \\
words(l\frown s \frown r)=(words \enspace l) \frown (words \enspace r)
\end{axdef}
\caption{}
\label{fig1}
\end{figure}
همانطور که در شکل 
\ref{fig1}
می بینید، الگوهای زیادی وجود ندارد. زمانیکه متن خالی باشد، نتیجه نیز خالی است. زمانیکه متن تنها شامل کاراکتر فاصله باشد، باز هم نتیجه خالی است. زمانیکه متن شامل تنها یک کلمه است، نتیجه دنباله ای است که شامل تنها یک کلمه می باشد. زمانیکه متن تنها شامل یک کلمه به همراه یک فاصله در ابتدا یا انتهای آن باشد، نتیجه مشابه حالت قبل است (یعنی دنباله ای که شامل یک کلمه است). و درنهایت اینکه هرزمان که متن شامل یک کاراکتر فاصله باشد، آنرا نادیده گرفته و متن را از محل فاصله، به دو بخش می شکنیم.
\\
این مثال تکنیک های مختلف موجود در Z را نشان می دهد که تعاریفی کوتاهتر و واضح تر از کد را ایجاد می کنند. تابع الگویی نظیر 
$l\frown s \frown r$
را بکار می برد که ساختار داخلی آرگومان
 هایشان را آشکار می کند. 
 \\
 تعداد کلمات موجود در متن $t$ بصورت
 $\#(words \enspace t)$
 نشان داده می شود. می توان تابعی تعریف کرد که مشابه کلمات، متن را به خطوط تشکیل دهنده اش بشکند. در چنین مثالی به جای فاصله، کاراکتر شکست خط را به عنوان یک کاراکتر خاص در نظر می گیریم و آن را $nl$ می نامیم. چنین توصیفی را در شکل 
 \ref{fig2}
 می توان مشاهده کرد.
 \\
 \begin{figure}
\centering
\begin{axdef}
lines: TEXT \rightarrow seq \enspace LINE
\ST
... definition \enspace omitted ...
\end{axdef}
\caption{}
\label{fig2}
\end{figure}
اکنون تمام آنچه را که برای توصیف رسمی عمل شمارش کلمات 
$Unix$
نیاز داریم، در اختیار داریم. تابعی که برای این مورد طراحی می شود را $wc$ می نامیم که آرگومان آن اسم یک فایل است و نتیجه آن یک چندتایی است که مولفه های آن، تعداد خطوط، کلمات و کاراکترهای موجود فایل می باشند. استفاده از این تابع بصورت زیر است.
\[
\% \enspace wc \enspace structure.tex\\
110 \enspace 559 \enspace 4509
\]
در شکل
\ref{fig3}
 تعریف $wc$ آمده است.
 \begin{figure}
\centering
\begin{axdef}
wc: TEXT \rightarrow (\mathbb{N} \times \mathbb{N} \times \mathbb{N})
\ST
\forall file:TEXT \bullet \\
wc \enspace file=(\#(lines \enspace files), \enspace \#(words \enspace file), \enspace \#file)\\
wc==(\lambda \enspace file:TEXT \bullet(\#(lines \enspace file),\enspace \#(words \enspace file), \enspace \#file))
\end{axdef}
\caption{}
\label{fig3}
\end{figure}
تقریبا اکثر ویراستارهای متن، عملیات $Fill$ را فراهم می کنند. عملیات $Fill$ متنی را که در آن خطوط، طول های مختلفی دارند، به متنی تبدیل می کند که طول خطوط در آن تقریبا یکسان است. این عملیات موجب زیباتر شدن متن می گردد.
\\
به عنوان مثال متن زیر را در نظر بگیرید:
\\
\begin{flushleft}
 
Almost any text editor provides a fill
operation. The fill operation transforms raggedy-looking text
with lines of
different lengths into nicely formatted text with lines
nearly the same length. 
\end{flushleft}

پس از اعمال عملیات $Fill$ متن به صورت زیر تبدیل می شود:

\begin{LTR}
Almost any text editor provides a fill
operation. The fill operation transforms raggedy-looking text
with lines of
different lengths into nicely formatted text with lines
nearly the same length.
\end{LTR}
اکنون به سراغ تعریف عملگر $Fill$ می رویم. در واقع $Fill$ تنها مثالی از عملیات $Format$ است که ظاهر متن را تغییر می دهد. $Format$ این کار را با شکستن خطوط به بخش های مختلف، گسترش یا انقباض فاصله بین کلمات، مشروط به اینکه هیچ خطی از عرض صفحه تجاوز نکند، انجام می دهد. توجه کنید که عملیات $Format$ نباید محتوای متن را تغییر دهد. در واقع این عملیات همان کلمات را به ترتیب اصلی خود در متن اصلی، حفظ می کند (شکل \ref{format}).
\\
\begin{figure}
\centering
\begin{schema}{Format}
width: \mathbb{N}\\
t,t': TEXT
\ST
words \enspace t'=words \enspace t
\forall I:\bold{ran}(lines \enspace t') \bullet \#I \leqslant width
\end{schema}
\caption{}
\label{format}
\end{figure}
عملیات $Fill$ همان عملیات $Format$ است که محدودیت اضافی را برآورده می کند. این محدودیت به این صورت است که خطوط تا حد امکان باید پر شوند. روش های مختلفی برای بیان این مطلب وجود دارد که هریک ظاهر متفاوتی به متن می دهند. شاید ساده ترین قانون این باشد که متن پر شده حداقل خطوط ممکن را اشغال کند. 
\begin{figure}
\centering
\begin{schema}{Fill}
Format
\ST
\# (lines \enspace t')=min\{t':TEXT | Format \bullet \# (lines \enspace t')\}
\end{schema}
\caption{}
\label{fill}
\end{figure}
تعریف شکل 
\ref{fill}
نشان می دهد که $Fill$ یک عملیات کمینه سازی است. این یک نوع خاص از $Format$ است که تعداد خطوط را به حداقل می رساند. درک این شِما کمی دشوار است زیرا به دو روش مختلف از $Format$ استفاده می کند و رخدادهای مختلف $t'$ نشاندهنده موارد مختلف هستند. $t'$ در سمت چپ تساوی به معنای حالت پایانی $Fill$ است. 
$t'$
در داخل تعریف مجموعه، متغیری محدود است که همه حالت های پایانی $Format$ را که از حالت شروع $Fill$ می توان به آنها رسید، گسترش می دهد. در داخل تعریف مجموعه، $Format$ به عنوان یک گزاره بکار می رود. 
$t$
در این $Format$ حالت اولیه شِمای $Fill$ است. 
\\
$Fill$
 غیرقطعی است. روش های مختلف زیادی برای شکستن خطوط و فاصله ها وجود دارند که تعداد خطوط را به حداقل می رسانند. در توصیف، غیرقطعیت معمولا چیز خوبی اسن. تعاریف غیرقطعی اغلب کوتاه تر و واضح تر هستند. این تعاریف جزئیات غیرضروری را حذف می کنند. زمانیکه به سراغ پیاده سازی می رویم، این تعاریف ما را در انتخاب، آزاد می گذارند و موجب افزایش بهره وری می شوند. 
 
 \section{نمونه سوم: سیستم کنترل اسناد}\index{sample3} 
 در اینجا مدلی برای یک سیستم کنترل اسناد ساده در $Z$ ارائه شده است. افرادی که با یکدیگر کار می کنند، نیازمند به اشتراک گذاری کارهایشان هستند اما این موضوع ممکن است منجر به ایجاد سوء تفاهم ها و سردرگمی هایی گردد. زمانیکه دو نفر بر روی یک چیز مشترک در حال کار هستند، ممکن است خطاهایی رخ دهد و انجام تغییرات منجر به ایجاد تصادم و تداخل با دیگری گردد (به عنوان مثال کار مشترک بر روی یک فایل برنامه نویسی). می توان از کامپیوتر برای جلوگیری کردن از بروز چنین خطاهایی استفاده کرد. در واقع این هدف یک سیستم کنترل اسناد است. دو مثال واقعی برای چنین سیستم هایی عبارتند از سیستم کنترل کد مبدا
 \LTRfootnote{Source Code Control System (SCCS)}
 و سیستم کنترل بازبینی
 \LTRfootnote{Revision Control System (RCS)} 
 .
 \\
 در اینجا قوانین غیررسمی سیستم آورده شده است:
 \\
1- اگر کاربری بخواهد یک سند را به ترتیب تغییراتی که در آن رخ داده، بررسی کند و این کاربر اجازه تغییر سند را نیز داشته باشد، و هیچ شخص دیگری در آن لحظه سند را تغییر ندهد، آنگاه آن کاربر می تواند سند را بررسی کند.
\\
2- به محض اینکه کاربری سندی را برای ویرایش بررسی کند، همه افراد دیگر از بررسی آن سند امتناع می کنند. البته افرادی که دارای مجوز خواندن هستند، می توانند سند را بخوانند.
\\
3- زمانیکه کاربر، سند را ویرایش کرد، باید آن را بررسی کند و به کاربرهای دیگر نیز امکان بررسی را بدهد.
\\
در ادامه مدل $Z$ مربوط به این سیستم آورده شده است. در ابتدا با معرفی دو مجموعه پایه شروع می کنیم. این دو مجموعه عبارتند از مجموعه افراد و مجموعه اسناد.
\begin{LTR}
[PERSON, DOCUMENT]
\end{LTR}
برخی از افراد اجازه تغییر اسناد خاصی را دارند. می توان این ویژگی را به عنوان رابطه بین اسناد و افراد مدل کرد.
\begin{LTR}
$permission: DOCUMENT \leftrightarrow PERSON $
\end{LTR}
این رابطه بصورت یک مجموعه از زوج مرتب هایی به شکل (سند، شخص) است. به عنوان مثال، فردی به نام مریم، می تواند توصیف را تغییر دهد، مریم و علی میتوانند طراحی را تغییر دهند و علی و احمد، امکان تغییر کد را دارند.
\begin{LTR}
Maryam, Ali, Ahmad: PERSON
\\
spec, design, code: DOCUMENT
\\
permission = \{(spec, Maryam), (design, Maryam), (design, Ali), (code, Ali), (code, Ahmad)\}
\end{LTR}
وضعیت سیستم منجر به تعریف رابطه دیگری از نوع رابطه ای که در بالا ذکر شد، می شود. این رابطه به این صورت است که اسناد توسط چه افرادی، بررسی شده اند. نیاز اصلی این است که یک سند، در یک زمان، تنها توسط یک فرد می تواند بررسی شود. بنابراین در این حالت، رابطه یک تابع است به این دلیل که هر شی موجود در دامنه، تنها به یک شی موجود در برد تابع، نگاشت می شود. 
  
 \begin{figure}
\centering
\begin{schema}{ِDocument}
checked\_out: DOCUMENT \nrightarrow PERSON
\ST
checked\_out \subseteq permission
\end{schema}
\caption{}
\label{Document}
\end{figure}
توجه کنید که در شکل
\ref{Document}
، 
$checked\_out$
یک تابع جزئی است که با پیکان 
$\nrightarrow$
مشخص می شود. این بدان معناسب که برخی از اسناد، ممکن است توسط هیچ فردی بررسی نشده باشند. با استفاده از گزاره این مطلب بیان می شود که تنها افرادی که اجازه تغییر سند را دارند، می توانند آن را بررسی کنند.
\begin{LTR}
checked\_out=\{(design, Maryam), (spec, Maryam), (code, Ahmad)\}
\end{LTR} 
در این مدلسازی، دو عملیات برای تغییر حالت مورد نیاز است
 که عبارتند از
$checkOut$
و
$checkIn$
. 
در شکل
\ref{checkout}
عملیات 
$checkOut$
 توصیف شده است. این عملیات دو پارامتر ورودی دارد: یکی فرد $p?$ و دیگری سند $d?$.

\begin{figure}
\centering
\begin{schema}{CheckOut}
\Delta Documents\\
p?:PERSON\\
d?:DOCUMENT
\ST
d? \notin \dom checked\_out\\
(d?,p?) \in permission\\
checked\_out' =checked\_out \cup \{(d?,p?)\}
\end{schema}
\caption{}
\label{checkout}
\end{figure}
$checkOut$ 
دو پیش شرط دارد.
اولین پیش شرط، بیان می کند که سند $d?$ تاکنون نباید بررسی شده باشد. این سند نمی تواند در دامنه 
$checked\_out$
قرار داشته باشد. علاوه بر این، شخص، نیاز به مجوز بررسی دارد:
$(d?, p?)$
 باید متعلق به 
 $permission$ باشد.
 اگر این دو پیش شرط برآورده شوند، آنگاه می توان زوج مرتب 
 $(d?, p?)$
 را به 
 $checked\_out$
 اضافه کرد. این مساله باعث می شود که شخص دیگری نتواند $d?$ را بررسی کند.
 \\
در ادامه به بررسی مواردی می پردازیم که در آن پیش شرط ها برآورده نشوند. دو پیش شرط وجود دارد بنابراین دو حالت هم برای برآورده نشدن آنها وجود دارد. یکی اینکه 
$checked\_out$
بگوید که این سند پیش از این بررسی شده است :
$d? \in dom checked\_out$ 
. 
\\
شِمای 
$Unauthorized$
( \ref{unauthorized} )
بیان می کند که شخص مجوز دسترسی به سند را ندارد:
$(d?, p?) \notin permission$
. 
\\
 در هر دو مورد، حالت سیستم تغییر نمی کند:
$\Xi Documents$
.
\begin{LTR}
$CheckedOut \cong [ \Xi Cocuments; d?:DOCUMENT | d? \in \dom checked\_out]$
\end{LTR} 


\begin{figure}
\centering
\begin{schema}{Unauthorized}
\Xi Documents\\
p?:PERSON\\
d?:DOCUMENT
\ST
(d?,p?) \notin permission
\end{schema}
\caption{}
\label{unauthorized}
\end{figure}
عملیات کلی
$T\_CheckOut$
سه وضعیت ممکن را پوشش می دهد. 
\begin{LTR}
$T\_CheckOut \cong checkOut \vee CheckedOut \vee Unauthorized$
\end{LTR}
این مثال کوچک، ویژگی های خاص مدل های $Z$ را نشان می دهد.
\\
شما می توانید جزئیات را نادیده بگیرید و بر جنبه هایی از مساله که مورد علاقه شماست، تمرکز کنید. در این مثال بیشترین تمرکز بر روی مجوزها و اینکه چه افرادی تاکنون اسناد را بررسی کرده اند، بوده است. در این مثال، مدلسازی از نحوه کپی کردن اسناد، بین مخزن مرکزی و دایرکتوری های محلی کاربران انجام نشده است. در اینجا، مجموعه ای از اسناد و کاربران، به عنوان مجموعه های ثابت مدل شده اند. همچنین مجوزها به عنوان یک ثابت، مدل شده اند. یک سیستم کنترل سند واقعی، باید روش هایی را برای اضافه کردن یک سند جدید و حذف سندهای قدیمی، فراهم کند. همچنین چنین سیستمی باید امکان انتساب و تغییر مجوزها را نیز داشته باشد. اگر بخواهیم تمام اینها را با استفاده از $Z$ مدل کنیم، باید افراد، اسناد و مجوزها را به عنوان متغیرهای موجود در شِما ارائه دهیم و دیگر این اشیا را نمی توان بصورت انواع پایه و ثوابت سراسری، تعریف کرد.
\\
مدل ها باید تا حد امکان ساده باشند. اگر در ایجاد مدل از توابع و گزاره های بسیار پیچیده استفاده شده است، مسلما روش اشتباهی در پیش گرفته شده است. باید اجازه داد که ویژگی های پایه مجموعه ها، روابط و توابع، کار را انجام دهند. این نیاز که تنها یک نفر در هر زمان بتواند یک سند را بررسی کند، توسط یک تابع قابل تعریف است. 
\\
نیازهای مرتبط با مجوزها، با استفاده از تابع $checked\_out$ که زیر مجموعه ای از رابطه $permission$ است، ارائه می شوند. در $Z$، توابع رابطه هستند و روابط مجموعه هستند بنابراین عملگرهایی که برای مجموعه ها تعریف شده اند، برای روابط و توابع نیز بکار برده می شوند و می توان تمام آنها را با یکدیگر در یک عبارت بکار برد. این یکی از مزایای $Z$ است که در دیگر نشان گذاری های رسمی یافت نمی شود. 


\section{نمونه چهارم: ماشین حالت متناهی}\index{sample4} 
در این مثال سه روشی را که برای نمایش مدل یک ماشین حالت متناهی وجود دارد، نشان داده شده است. این سه روش عبارتند از: دیاگرام، جدول و Z.
\subsection{دیاگرام انتقال حالت}
یکی از روش های نمایش ماشین های حالت متناهی، استفاده از دیاگرام انتقال حالت
\LTRfootnote{State transition diagram}
 است. در شکل  یک مثال از این دیاگرام آورده شده است.
\begin{figure}

\end{figure}
حالت ها بصورت دایره هایی نشان داده می شوند؛ انتقال بین حالت ها با استفاده از پیکان مشخص می شود. برچسب هر پیکان رخدادی است که منجر به انتقال از حالت مبدا به حالت مقصد می شود. بنابراین در شکل    ، زمانیکه در حالت $PATIENTS$ قرار دارد، با فشار دادن کلید $ENTER$، ماشین به حالت $FIELDS$ منتقل می شود و در حالت $FIELDS$ با فشردن کلید $ENTER$، انتقال به حالت $SETUP$ رخ می دهد. 
\\
می توان دنباله رفتارهای ممکن ماشین را، با دنبال کردن پیکان های ماشین، ردیابی کرد.
\subsection{جدول انتقال حالت}
دیاگرام انتقال حالت، یک تصویر از مدل ماشین حالت متناهی ارائه می دهد. روش های دیگری نیز برای نمایش مدل مشابه وجود دارند. یکی از این روش ها جدول انتقال حالت
\LTRfootnote{State transition table}
 است.



\begin{LTR}
STATE::=patients|fields|setup|ready|beam\_on\\
EVENT::=select\_patient |select\_field |enter|start|stop|ok|intlk\\
$FSM::=(STATE \times EVENT)\nrightarrow STATE$
\end{LTR}

\begin{figure}
\centering
\begin{axdef}
no\_change, transitions, control: FSM
\ST
control=no\_change \oplus transitions\\
no\_change= \{s:STATE ;e:EVENT \bullet(s,e)\mapsto s\}\\
transitions=\{(patients, enter) \mapsto fields,\\
\enspace (fields, select\_patient ) \mapsto patients, (fields,enter) \mapsto setup,\\
\enspace (setup, select\_patient ) \mapsto patients, (setup, select\_field)) \mapsto fields, (setup, ok)\mapsto ready,\\
\enspace (ready, select\_patient ) \mapsto patients, (ready,select\_field) \mapsto fields, (ready, start) \mapsto beam\_on, (ready, intlk)\mapsto setup,\\
\enspace (beam\_on, stop) \mapsto ready, (beam\_on, intlk) \mapsto setup\}
\end{axdef}
\caption{}
\label{fig3}
\end{figure}